---
jupyter: mkernel
---

```{matlab}
%| include: false
clear
setappdata(0, "MKernel_plot_backend", "inline")
setappdata(0, "MKernel_plot_format", "svg")
addpath( "../lecture_00/" )
addpath( "../lecture_01/" )
addpath( "../lecture_03/" )
```

# Quadrature on Piecewise Polynomials

Thus far we have discussed quadrature on a function composed of a single polynomial function.
However, we previously demonstrated a desire -- or rather, a practical necessity -- to use *piecewise* polynomial functions as the basis functions in our Galerkin approach.
Therefore, we need to extend our polynomial quadrature to the piecewise polynomial.
<!-- While we *could* compute a quadrature scheme on the piecewise polynomial, and in fact we will demonstrate this, by far the simplest approach (and the one most widely used) is to use change of variables on each piecewise domain (element). -->

There are three approaches that we can use to apply quadrature:

1. Moment-fitting
2. Piecewise quadrature rule
3. Piecewise quadrature rule on reference element

## Moment-fitting

```{matlab}
%| output: true
x = sym( "x", "real" );
basis_name = "Lagrange";
num_elements = 4;
degree = 2 * ones( 1, num_elements );
continuity = [-1, 0 * ones( 1, num_elements - 1 ) -1];
domain = sym( [0, 1] );
vertices = linspace( domain(1), domain(2), num_elements + 1 );
spline_space = SplineSpace( basis_name, x, degree, vertices, continuity );
spline = Spline( spline_space );
num_coeffs = numel( spline.basis );

%coeffs = [1; 2; 2.5; 2; 1];
%coeffs = [1; 2; 2; 1.25; 1; 1; 1.25; 1.5; 2];
coeffs = subs( real( x^x ), x, linspace( domain(1), domain(2), num_coeffs ).' )
piecewise_polynomial = transpose( coeffs ) * spline.basis;
int( piecewise_polynomial, domain );

figure
fplot( piecewise_polynomial, double( domain ), LineWidth=3 )
xline( double( vertices ), LineWidth=1, LineStyle=":" )
axis padded
%ax = gca;
%ax.YLim = [0, 3];

quad_int = sym( 0 );
x_qp = [];
w_qp = [];
for elem_id = 1 : num_elements
    elem_domain = spline.GetElementDomain( elem_id );
    elem_degree = spline.GetElementDegree( elem_id );
    [elem_x_qp, elem_w_qp] = GetQuadratureScheme( elem_domain, elem_degree + 1, "Lagrange" );
    x_qp = [x_qp; elem_x_qp];
end

x_qp = unique( transpose( x_qp ) )
w_qp = LinearMomentFitting( spline.basis, domain, x_qp )

subs( piecewise_polynomial, x, x_qp.' );
PlotQuadrature( double( x_qp ), double( w_qp ), double( subs( piecewise_polynomial, x, x_qp.' ) ) )
%ref_piecewise_polynomial = ChangeOfVariable( piecewise_polynomial, elem_domain, ref_elem_domain )
%ref_piecewise_polynomial = subs( piecewise_polynomial, x, xi )
elem_int = sym( 0 );
for ii = 1 : length( x_qp )
    quad_int = quad_int + ( w_qp(ii) * subs( piecewise_polynomial, x, x_qp(ii) ) );
end
quad_int
```

## Piecewise quadrature

```{matlab}
%| output: true
x = sym( "x", "real" );
basis_name = "Lagrange";
num_elements = 4;
degree = 2 * ones( 1, num_elements );
continuity = [-1, 0 * ones( 1, num_elements - 1 ) -1];
domain = sym( [0, 1] );
vertices = linspace( domain(1), domain(2), num_elements + 1 );
spline_space = SplineSpace( basis_name, x, degree, vertices, continuity );
spline = Spline( spline_space );
num_coeffs = numel( spline.basis );

%coeffs = [1; 2; 2.5; 2; 1];
%coeffs = [1; 2; 1; 2; 1; 2; 1; 2; 1];
coeffs = subs( real( x^x ), x, linspace( domain(1), domain(2), num_coeffs ).' )
piecewise_polynomial = transpose( coeffs ) * spline.basis;
int( piecewise_polynomial, domain );

figure
fplot( piecewise_polynomial, double( domain ), LineWidth=3 )
xline( double( vertices ), LineWidth=1, LineStyle=":" )
axis padded
%ax = gca;
%ax.YLim = [0, 3];

quad_int = sym( 0 );
x_qp = [];
w_qp = [];
for elem_id = 1 : num_elements
    elem_domain = spline.GetElementDomain( elem_id );
    elem_degree = spline.GetElementDegree( elem_id );
    [elem_x_qp, elem_w_qp] = GetQuadratureScheme( elem_domain, elem_degree + 1, "Lagrange" );
    x_qp = [x_qp; elem_x_qp];
    w_qp = [w_qp; elem_w_qp];
end

x_qp;
w_qp;

%[x_qp, idx] = unique( x_qp )
%w_qp = w_qp( idx )

subs( piecewise_polynomial, x, x_qp.' );
PlotQuadrature( double( x_qp ), double( w_qp ), double( subs( piecewise_polynomial, x, x_qp.' ) ) )
%ref_piecewise_polynomial = ChangeOfVariable( piecewise_polynomial, elem_domain, ref_elem_domain )
%ref_piecewise_polynomial = subs( piecewise_polynomial, x, xi )
elem_int = sym( 0 );
for ii = 1 : length( x_qp )
    elem_int = elem_int + ( w_qp(ii) * subs( piecewise_polynomial, x, x_qp(ii) ) );
end
quad_int = quad_int + elem_int;
```

## Reference element quadrature

The final approach we'll discuss is the one that is ubiquitous in finite element method implementations.
In this technique we construct the basis functions and quadrature scheme on a single *parametric* element within a *parametric* domain, and then "map" the integral back to the actual domain of each element.
For example, recalling our previous discussion of *change of variable*, we wish to integrate some function, $f(x)$, over the domain $\mathcal{X}\in [x_0, x_1]$.

```{matlab}
clear
x = sym( "x", "real" );
xi = sym( "xi", "real" );
x_domain = sym( [ 2*pi, 4*pi ] );
xi_domain = sym( [ -1, 1 ] );

X(xi) = ChangeOfVariable( x, xi_domain, x_domain );

f(x) = -sin( x / 2 );
g(x) = subs( f, x, X );

cmap = lines( 2 );
figure
subplot( 2, 1, 1 )
farea( f, double( x_domain ), LineWidth=2, EdgeColor=cmap(1,:), FaceColor=cmap(1,:) );
xlabel( "$x$", Interpreter="latex" )
ylabel( "$f(x)$", Interpreter="latex" )
ax(1) = gca;
ax(1).XLim = double( [min( [x_domain(1), xi_domain(1)] ), max( [x_domain(2), xi_domain(2)] ) ] );
subplot( 2, 1, 2 )
farea( g, double( xi_domain ), LineWidth=2, EdgeColor=cmap(2,:), FaceColor=cmap(2,:) );
xlabel( "$\xi$", Interpreter="latex" )
ylabel( "$f(x(\xi))$", Interpreter="latex" )
ax(2) = gca;
ax(2).XLim = double( [min( [x_domain(1), xi_domain(1)] ), max( [x_domain(2), xi_domain(2)] ) ] );

```

Through the application of change of variables we can describe this as

```{=latex}
\begin{equation*}
        \int_{x_0}^{x_1}{f(x) \d x } = \int_{\xi_0}^{\xi_1}{ f(x(\xi)) \frac{d x(\xi)}{d \xi} \d \xi},
\end{equation*}
```

where $\frac{ d x(\xi)}{d\xi}$ is known as the *Jacobian* and describes how the function changes through the change of variables operation.
Note that in this one-dimensional case, where we've used change of variable, the Jacobian can be computed as

```{=latex}
\begin{align*}
        x(\xi) &\defequals \left( \left( \xi - \xi_0 \right) \frac{x_1 - x_0}{\xi_1 - \xi_0} \right) + x_0 \\
        %
        \frac{ dx(\xi) }{ d\xi } &= \frac{ x_1 - x_0 }{ \xi_1 - \xi_0 } \\
\end{align*}
```

Substituting this into our previous result we have:

```{=latex}
\begin{align*}
        \int_{x_0}^{x_1}{f(x) \d x } &= \int_{\xi_0}^{\xi_1}{ f(x(\xi)) \frac{ x_1 - x_0 }{ \xi_1 - \xi_0 } \d \xi} \\
        %
        \int_{x_0}^{x_1}{f(x) \d x } &= \frac{ x_1 - x_0 }{ \xi_1 - \xi_0 } \int_{\xi_0}^{\xi_1}{ f(x(\xi))  \d \xi} \\
\end{align*}
```

which we can then integrate, at least approximately, with a quadrature scheme of our choice over the parametric domain:

```{=latex}
\begin{equation*}
        \int_{x_0}^{x_1}{f(x) \d x } \approx \frac{ x_1 - x_0 }{ \xi_1 - \xi_0 } \sum_{i=1}^{n} f(x(\xi_{\Index{i}})) w_{\Index{i}}
\end{equation*}
```


The previous approaches, while useful to understand what is being accomplished by this "element poin"

```{matlab}
function domain = GetPolynomialReferenceElementDomain( basis_name )
    switch basis_name
        case "Bernstein"
            domain = [0, 1];
        case "Chebyshev"
            domain = [-1, 1];
        case "Lagrange"
            domain = [-1, 1];
        case "Legendre"
            domain = [-1, 1];
        case "Lagrange-Legendre"
            domain = [-1, 1];
        case "Monomial"
            domain = [0, 1];
    end
end
```



```{matlab}
%| output: true
x = sym( "x", "real" );
basis_name = "Lagrange";
num_elements = 4;
degree = 2 * ones( 1, num_elements );
continuity = [-1, 0 * ones( 1, num_elements - 1 ) -1];
domain = sym( [0, 1] );
vertices = linspace( domain(1), domain(2), num_elements + 1 );
spline_space = SplineSpace( basis_name, x, degree, vertices, continuity );
spline = Spline( spline_space );
num_coeffs = numel( spline.basis );

%coeffs = [1; 2; 2.5; 2; 1];
%coeffs = [1; 2; 1; 2; 1; 2; 1; 2; 1];
coeffs = subs( real( x^x ), x, linspace( domain(1), domain(2), num_coeffs ).' )
piecewise_polynomial = transpose( coeffs ) * spline.basis;
int( piecewise_polynomial, domain )

figure
fplot( piecewise_polynomial, double( domain ), LineWidth=3 )
xline( double( vertices ), LineWidth=1, LineStyle=":" )
axis padded
%ax = gca;
%ax.YLim = [0, 3];

quad_int = sym( 0 );
x_qp = [];
w_qp = [];
for elem_id = 1 : num_elements
    elem_domain = spline.GetElementDomain( elem_id );
    elem_degree = spline.GetElementDegree( elem_id );
    elem_basis_ids = spline.GetSupportedBasisIdsFromElementId( elem_id );
    elem_coeffs = coeffs( elem_basis_ids );
    ref_elem_domain = GetPolynomialReferenceElementDomain( basis_name );
    ref_elem_basis = PolynomialBasisFunction( "Lagrange", elem_degree, x, ref_elem_domain );
    [elem_x_qp, elem_w_qp] = GetQuadratureScheme( ref_elem_domain, elem_degree + 1, "Lagrange" );
    xi = ChangeOfVariable( x, ref_elem_domain, elem_domain );
    elem_quad_int = sym( 0 );
    jacobian = diff( xi, x, 1 );
    for ii = 1 : length( elem_x_qp )
        elem_quad_int = elem_quad_int + sum( subs( elem_coeffs .* ref_elem_basis * jacobian, x, elem_x_qp(ii) ) ) * elem_w_qp(ii);
    end
    quad_int = quad_int + elem_quad_int
end

%PlotQuadrature( double( x_qp ), double( w_qp ), double( subs( piecewise_polynomial, x, x_qp.' ) ) )
%elem_int = sym( 0 );
%for ii = 1 : length( x_qp )
%    elem_int = elem_int + ( w_qp(ii) * subs( piecewise_polynomial, x, x_qp(ii) ) );
%end
%quad_int = quad_int + elem_int;
```