---
jupyter: mkernel
---

```{matlab}
%| include: false
clear
setappdata(0, "MKernel_plot_backend", "inline")
setappdata(0, "MKernel_plot_format", "svg")
addpath( "../lecture_00/" )
```

# Incorporating Boundary Conditions in Galerkin's Method

We previously showed the Galerkin method as being *the best* approximation of a function over a domain, which implies that there are *other* approximations of the function.
We also observed that, because the approximation is merely trying to minimize the $L^2$ error over the entire domain, that there is no guarantee that it is the best approximation of the function at any arbitrary point.
Indeed, for the approximation to be the "best approximation" of the function at any arbitrary point, it would have to be the best approximation at every point -- the approximation would need to be equivalent to the target function.

But what if we only care about being the best approximation of the function at a few points, for example: at the boundaries of the domain?
While this might itself seem arbitrary, consider that in real-world applications we often know the conditions at physical boundaries -- either through direct measurement or intuition.
For example, we might directly measure the temperature of a device using thermal imaging or thermocouples, which measure temperature at the boundary of an object.
Or we might safely assume that a long beam that is welded to a much stiffer object has zero displacement at the shared interface.
Because these conditions are often applied on boundaries, they are historically called *boundary conditions*.

We modify the Galerkin statement function from the previous section to include this desire to produce the best approximation of the function at its boundaries.

```{=latex}
\begin{equation}
    \begin{alignedat}{2}
        &\textrm{Given:}      & \quad g(x) &= \sin(\pi x)^2 + \cos(x) - 1 \\
        &\textrm{Find:}       & \quad \tilde{g}(x) &\in \tilde{\mathcal{V}} \\
        &\textrm{such that:}  & \quad \Inner{\tilde{\mathcal{V}}}{\tilde{g}(x)} &= \Inner{\tilde{\mathcal{V}}}{g(x)} \\
        &\textrm{subject to:} & \quad \tilde{g}(0) &= g(0) \\
        &                     & \quad \tilde{g}(1) &= g(1) \\
    \end{alignedat}
\end{equation}
```

We need to determine how to enforce our boundary conditions.
The methods we can take broadly fall into one of two categories: 

- *Weak-enforcement* 
    - Boundary conditions are defined as a weak-formulation.
    - Boundary conditions not strictly enforced but may be "arbitrarily close".
- *Strong-enforcement*
    - A basis is chosen that interpolates the boundary condition.
    - Boundary conditions are strictly enforced.

## Weakly-enforced boundary conditions
We'll enumerate the methods first, before diving into each.

1. Penalty method
    a. With Dirac Delta function
    b. With function evaluation
2. Lagrange multipliers

### Penalty Method
We begin by applying our change of basis perspective to the boundary conditions; we want to represent $g(0)$ and $g(1)$ in our finite basis:

```{=latex}
\begin{align}
    %%%%%%%%%%%%%
    %%% EQN 1 %%%
    %%%%%%%%%%%%%
    \Inner{\Matrix{T}}{\Matrix{T}} \Vector{t} &= \Inner{\Matrix{T}}{\Matrix{F}} \Vector{f} \\
    %%%%%%%%%%%%%
    %%% EQN 2 %%%
    %%%%%%%%%%%%%
    \begin{bmatrix}
        \Inner{\Matrix{T}_1}{\Matrix{T}_1} & \cdots & \Inner{\Matrix{T}_1}{\Matrix{T}_n} \\
        \vdots & \ddots & \vdots \\
        \Inner{\Matrix{T}_n}{\Matrix{T}_1} & \cdots & \Inner{\Matrix{T}_m}{\Matrix{T}_n}
    \end{bmatrix}\
    \begin{bmatrix}
        t_0 \\ \vdots \\ t_n
    \end{bmatrix}
    &=
    \begin{bmatrix}
        \Inner{\Matrix{T}_1}{g(0)} \\
        \vdots \\
        \Inner{\Matrix{T}_m}{g(0)}
    \end{bmatrix}
\end{align}
```

Where the "To"-basis is our chosen polynomial basis, $\Matrix{M}$, *evaluated* at the boundary condition, which we can represent using the Dirac delta function:

```{=latex}
\begin{equation}
    T_{\Index{i}} = \Inner{M_{\Index{i}}}{\DiracDelta{x}{0}}
\end{equation}
```

For simplicity, we introduce the notation $\DiracDeltaShort{x}{a}$ as shorthand for $\DiracDelta{x}{a}$

```{=latex}
\begin{equation}
    T_{\Index{i}} = \Inner{M_{\Index{i}}}{\DiracDeltaShort{x}{0}}
\end{equation}
```

And thus the boundary condition at $x=0$ can be written as

<!-- ```{=latex}
\begin{align*}
    \begin{bmatrix} 
        \Inner{T_{\Index{i}}}{T_{\Index{j}}}
    \end{bmatrix}
    &=
    \begin{bmatrix}
        \Inner{ \Inner{ M_{\Index{i}} }{\DiracDeltaShort{x}{0}} }{ \Inner{ M_{\Index{j}} }{\DiracDeltaShort{x}{0}}}
    \end{bmatrix} \\
    %%%%%%
    \begin{bmatrix} 
        \Inner{T_{\Index{i}}}{g(0)}
    \end{bmatrix}
    &=
    \begin{bmatrix}
        \Inner{ \Inner{ M_{\Index{i}} }{\DiracDeltaShort{x}{0}} }{ g(0) }
    \end{bmatrix}
\end{align*}
``` -->

```{=latex}
\begin{equation}
    \begin{split}
        \begin{bmatrix}
            \Inner{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{0}} }{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{0}} } & \cdots & \Inner{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{0}} }{ \Inner{ M_{\Index{n}} }{\DiracDeltaShort{x}{0}} } \\
            \vdots & \ddots & \vdots \\
            \Inner{ \Inner{ M_{\Index{m}} }{\DiracDeltaShort{x}{0}} }{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{0}} } & \cdots & \Inner{ \Inner{ M_{\Index{m}} }{\DiracDeltaShort{x}{0}} }{ \Inner{ M_{\Index{n}} }{\DiracDeltaShort{x}{0}} }
        \end{bmatrix}
        \begin{bmatrix}
            t_0 \\ \vdots \\ t_{\Index{n}}
        \end{bmatrix}
        =
        \begin{bmatrix}
            \Inner{ \Inner{M_1}{\DiracDeltaShort{x}{0}} }{g(0)} \\
            \vdots \\
            \Inner{ \Inner{M_{\Index{m}}}{\DiracDeltaShort{x}{0}} }{g(0)}
        \end{bmatrix}
    \end{split}
\end{equation}
```

Similarly, the boundary condition at $x=1$ can be written as

<!-- ```{=latex}
\begin{align*}
    \begin{bmatrix} 
        \Inner{T_{\Index{i}}}{T_{\Index{j}}}
    \end{bmatrix}
    &=
    \begin{bmatrix}
        \Inner{ \Inner{ M_{\Index{i}} }{\DiracDelta{x}{1}} }{ \Inner{ M_{\Index{j}} }{\DiracDelta{x}{1}}}
    \end{bmatrix} \\
    %%%%%%
    \begin{bmatrix} 
        \Inner{T_{\Index{i}}}{g(1)}
    \end{bmatrix}
    &=
    \begin{bmatrix}
        \Inner{ \Inner{ M_{\Index{i}} }{\DiracDelta{x}{1}} }{ g(1) }
    \end{bmatrix}
\end{align*}
``` -->

```{=latex}
\begin{equation}
    \begin{split}
        \begin{bmatrix}
            \Inner{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{1}} }{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{1}} } & \cdots & \Inner{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{1}} }{ \Inner{ M_{\Index{n}} }{\DiracDeltaShort{x}{1}} } \\
            \vdots & \ddots & \vdots \\
            \Inner{ \Inner{ M_{\Index{m}} }{\DiracDeltaShort{x}{1}} }{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{1}} } & \cdots & \Inner{ \Inner{ M_{\Index{m}} }{\DiracDeltaShort{x}{1}} }{ \Inner{ M_{\Index{n}} }{\DiracDeltaShort{x}{1}} }
        \end{bmatrix}
        \begin{bmatrix}
            t_0 \\ \vdots \\ t_{\Index{n}}
        \end{bmatrix}
        =
        \begin{bmatrix}
            \Inner{ \Inner{M_1}{\DiracDeltaShort{x}{1}} }{g(1)} \\
            \vdots \\
            \Inner{ \Inner{M_{\Index{m}}}{\DiracDeltaShort{x}{1}} }{g(1)}
        \end{bmatrix}
    \end{split}
\end{equation}
```

And we recall that from the change of basis we have

```{=latex}
\begin{equation}
    \begin{bmatrix}
        \Inner{M_1}{M_1} & \cdots & \Inner{M_1}{M_{\Index{n}}} \\
        \vdots           & \ddots & \vdots \\
        \Inner{M_{\Index{m}}}{M_1} & \cdots & \Inner{M_{\Index{m}}}{M_{\Index{n}}}
    \end{bmatrix}
    \begin{bmatrix}
        t_0 \\ \vdots \\ t_{\Index{n}}
    \end{bmatrix}
    =
    \begin{bmatrix}
        \Inner{M_1}{g(x)} \\
        \vdots \\
        \Inner{M_{\Index{m}}}{g(x)}
    \end{bmatrix}
\end{equation}
```

Thus we have three sets of equations:

```{=latex}
\begin{align}
    \begin{bmatrix} \Inner{ M_{\Index{i}} }{ M_{\Index{j}} } \end{bmatrix} \Vector{t} &= \begin{bmatrix} \Inner{ M_{\Index{j}} }{ g(x) } \end{bmatrix} \\
    %
    \begin{bmatrix} \Inner{ \Inner{ M_{\Index{i}} }{\DiracDeltaShort{x}{0}} }{ \Inner{ M_{\Index{j}} }{\DiracDeltaShort{x}{0}} } \end{bmatrix} \Vector{t} &= \begin{bmatrix} \Inner{M_{\Index{j}}}{g(0)} \end{bmatrix} \\
    %
    \begin{bmatrix} \Inner{ \Inner{ M_{\Index{i}} }{\DiracDeltaShort{x}{1}} }{ \Inner{ M_{\Index{j}} }{\DiracDeltaShort{x}{1}} } \end{bmatrix} \Vector{t} &= \begin{bmatrix} \Inner{M_{\Index{j}}}{g(1)} \end{bmatrix} \\
\end{align}
```

The penalty method approach allows us to control how strictly the solution should respect the boundary conditions.
This is done by introducing a scalar parameter, $\rho \in [0, \infty)$, called the *penalty factor*, that scales each boundary condition's respective system of equations.
When $\rho = 0$ the boundary condition is removed from consideration in the solution and in the limit as $\rho \rightarrow \infty$ the boundary condition is exactly satisfied in the solution.

We rewrite our systems of equations for the penalty-method approach as:

```{=latex}
\begin{align}
    \begin{bmatrix} \Inner{ M_{\Index{i}} }{ M_{\Index{j}} } \end{bmatrix} \Vector{t} &= \begin{bmatrix} \Inner{ M_{\Index{j}} }{ g(x) } \end{bmatrix} \\
    %
    \rho \begin{bmatrix} \Inner{ \Inner{ M_{\Index{i}} }{\DiracDeltaShort{x}{0}} }{ \Inner{ M_{\Index{j}} }{\DiracDeltaShort{x}{0}} } \end{bmatrix} \Vector{t} &= \rho \begin{bmatrix} \Inner{M_{\Index{j}}}{g(0)} \end{bmatrix} \\
    %
    \rho \begin{bmatrix} \Inner{ \Inner{ M_{\Index{i}} }{\DiracDeltaShort{x}{1}} }{ \Inner{ M_{\Index{j}} }{\DiracDeltaShort{x}{1}} } \end{bmatrix} \Vector{t} &= \rho \begin{bmatrix} \Inner{M_{\Index{j}}}{g(1)} \end{bmatrix} \\
\end{align}
```

We can assemble these equations into a single equation:

```{=latex}
\begin{equation}
    \begin{bmatrix} \Inner{M_{\Index{i}}}{M_{\Index{j}}} \end{bmatrix} \Vector{t} 
    + 
    \rho \begin{bmatrix} \Inner{ \Inner{ M_{\Index{i}} }{\DiracDeltaShort{x}{0}} }{ \Inner{ M_{\Index{j}} }{\DiracDeltaShort{x}{0}} } \end{bmatrix} \Vector{t} 
    +
    \rho \begin{bmatrix} \Inner{ \Inner{ M_{\Index{i}} }{\DiracDeltaShort{x}{1}} }{ \Inner{ M_{\Index{j}} }{\DiracDeltaShort{x}{1}} } \end{bmatrix} \Vector{t}
    = 
    \begin{bmatrix} \Inner{M_{\Index{i}}}{g(x)} \end{bmatrix} 
    +
    \rho \begin{bmatrix} \Inner{ \Inner{M_{\Index{i}}}{\DiracDeltaShort{x}{0}} }{g(0)} \end{bmatrix}
    +
    \rho \begin{bmatrix} \Inner{ \Inner{M_{\Index{i}}}{\DiracDeltaShort{x}{1}} }{g(1)} \end{bmatrix}
\end{equation}
```

Factoring out the $\Vector{t}$ this simplifies to

```{=latex}
\begin{equation}
    \left(
        \begin{bmatrix} \Inner{M_{\Index{i}}}{M_{\Index{j}}} \end{bmatrix} 
        + 
        \rho \begin{bmatrix} \Inner{ \Inner{ M_{\Index{i}} }{\DiracDeltaShort{x}{0}} }{ \Inner{ M_{\Index{j}} }{\DiracDeltaShort{x}{0}} } \end{bmatrix}
        +
        \rho \begin{bmatrix} \Inner{ \Inner{ M_{\Index{i}} }{\DiracDeltaShort{x}{1}} }{ \Inner{ M_{\Index{j}} }{\DiracDeltaShort{x}{1}} } \end{bmatrix} 
    \right)
    \Vector{t}
    = 
    \left(
        \begin{bmatrix} \Inner{M_{\Index{i}}}{g(x)} \end{bmatrix} 
        +
        \rho \begin{bmatrix} \Inner{ \Inner{M_{\Index{i}}}{\DiracDeltaShort{x}{0}} }{g(0)} \end{bmatrix}
        +
        \rho \begin{bmatrix} \Inner{ \Inner{M_{\Index{i}}}{\DiracDeltaShort{x}{1}} }{g(1)} \end{bmatrix}
    \right)
\end{equation}
```

or, in expanded matrix form

```{=latex}
\begin{equation}
    \begin{bmatrix}
        \Inner{M_{\Index{1}}}{M_{\Index{1}}} + \rho \Inner{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{0}} }{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{0}} } + \rho \Inner{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{1}} }{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{1}} } & \cdots & \Inner{M_{\Index{1}}}{M_{\Index{n}}} + \rho \Inner{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{0}} }{ \Inner{ M_{\Index{n}} }{\DiracDeltaShort{x}{0}} } + \rho \Inner{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{1}} }{ \Inner{ M_{\Index{n}} }{\DiracDeltaShort{x}{1}} }\\
        \vdots & \ddots & \vdots \\
        \Inner{M_{\Index{m}}}{M_{\Index{1}}} + \rho \Inner{ \Inner{ M_{\Index{m}} }{\DiracDeltaShort{x}{0}} }{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{0}} } + \rho \Inner{ \Inner{ M_{\Index{m}} }{\DiracDeltaShort{x}{1}} }{ \Inner{ M_{\Index{1}} }{\DiracDeltaShort{x}{1}} } & \cdots & \Inner{M_{\Index{m}}}{M_{\Index{n}}} + \rho \Inner{ \Inner{ M_{\Index{m}} }{\DiracDeltaShort{x}{0}} }{ \Inner{ M_{\Index{n}} }{\DiracDeltaShort{x}{0}} } + \rho \Inner{ \Inner{ M_{\Index{m}} }{\DiracDeltaShort{x}{1}} }{ \Inner{ M_{\Index{n}} }{\DiracDeltaShort{x}{1}} }\\
    \end{bmatrix}
    \begin{bmatrix}
        t_1 \\ \vdots \\ t_\Index{n}
    \end{bmatrix}
    =
    \begin{bmatrix}
        \Inner{M_{\Index{1}}}{g(x)} + \rho \Inner{ \Inner{M_{\Index{1}}}{\DiracDeltaShort{x}{0}} }{g(0)} + \rho \Inner{ \Inner{M_{\Index{1}}}{\DiracDeltaShort{x}{1}} }{g(1)} \\
        \vdots \\
        \Inner{M_{\Index{m}}}{g(x)} + \rho \Inner{ \Inner{M_{\Index{m}}}{\DiracDeltaShort{x}{0}} }{g(0)} + \rho \Inner{ \Inner{M_{\Index{m}}}{\DiracDeltaShort{x}{1}} }{g(1)} \\
    \end{bmatrix}
\end{equation}
```

We can modify our original `ScalarProjection` function to support these boundary conditions

```{matlab}
%| output: false
%| echo: false
classdef PolynomialSolutionSpace
    properties
        basis_name
        degree
        variate
        domain
        penalty
    end
end
```

```{matlab}
%| output: false
function [u, D, F, basis, d] = ScalarProjection( fun, sol_space )

    function [D, F] = ApplyGoverningEquation()
        function D = AssembleGramMatrix()
            D = int( basis * transpose( basis ), domain );
        end

        function F = AssembleForceVector()
            F = int( basis * target_fun, domain );
        end
        D = AssembleGramMatrix();
        F = AssembleForceVector();
    end

    function [D, F] = ApplyBoundaryConditions( D, F )
        function [D, F] = LeftFunctionValue()
            D = subs( ( basis ) .* transpose( basis ), variate, domain(1) );
            F = subs( basis * target_fun, variate, domain(1) );
        end
        function [D, F] = RightFunctionValue()
            D = subs( ( basis ) .* transpose( basis ), variate, domain(2) );
            F = subs( basis * target_fun, variate, domain(2) );
        end
        [DL, FL] = LeftFunctionValue();
        [DR, FR] = RightFunctionValue();
        D = D + penalty * ( DL + DR );
        F = F + penalty * ( FL + FR );
    end

    % Unpack the solution space
    variate = sol_space.variate;
    basis_name = sol_space.basis_name;
    degree = sol_space.degree;
    sol_domain = sol_space.domain;
    penalty = sol_space.penalty;
    
    % Unpack the function parameters
    target_fun = fun.target_fun;
    domain = fun.domain;

    % Solve
    basis = PolynomialBasisFunction( basis_name, degree, variate, sol_domain );
    [D, F] = ApplyGoverningEquation();
    [D, F] = ApplyBoundaryConditions( D, F );
    d = D \ F;
    u = transpose( d ) * basis;
end
```

```{matlab}
clear
x = sym( "x", "real" );
fun.target_fun = sin( pi * x )^2 + cos( x ) - 1;
fun.domain = [0, 1];

sol_space = PolynomialSolutionSpace();
sol_space.variate = x;
sol_space.domain = [0, 1];
sol_space.degree = 2;
sol_space.penalty = 100;
sol_space.basis_name = "Monomial";
[u, M, F, basis, d] = ScalarProjection( fun, sol_space );
```

```{matlab}
%| echo: false
figure
hold on
fplot( fun.target_fun, double( fun.domain ), linewidth=4, DisplayName="$f(x)$" )
fplot( u, double( fun.domain ),              linewidth=3, DisplayName="$\tilde{f}(x)$" )
legend()
```

```{matlab}
%| echo: false
figure
hold on
fplot( sqrt( ( u - fun.target_fun )^2 ), double( fun.domain ), linewidth=4, DisplayName="$f(x)$" )
```

### Augmented-Lagrange Method
We begin by applying our change of basis perspective to the boundary conditions; we want to represent $g(0)$ and $g(1)$ in our finite basis:

```{matlab}
%| output: false
%| echo: false
classdef PolynomialSolutionSpace
    properties
        basis_name
        degree
        variate
        domain
    end
end
```

```{matlab}
%| output: false
function [u, D, F, basis, d, lambda] = ScalarProjection(fun, sol_space)
    function [D, F] = ApplyGoverningEquation()
        D = int( basis * transpose(basis), domain );
        F = int( basis * target_fun,       domain );
    end

    function [D, F] = ApplyBoundaryConditions(D, F)
        % Constraint matrix C d = g*
        C = [transpose(subs(basis, variate, domain(1))); 
             transpose(subs(basis, variate, domain(2)))];

        g = [subs(target_fun, variate, domain(1)); 
             subs(target_fun, variate, domain(2))];

        n = length(basis);      % number of trial DOFs
        m = size(C,1);          % number of constraints (here 2)

        % Build (augmented) KKT system
        Z = sym( zeros( m, m ) );
        D = [D, C.'; C, Z];
        F = [F; g];
    end

    % Unpack the solution space
    variate    = sol_space.variate;
    basis_name = sol_space.basis_name;
    degree     = sol_space.degree;
    sol_domain = sol_space.domain;

    % Unpack the function parameters
    target_fun = fun.target_fun;
    domain     = fun.domain;

    % Solve
    basis = PolynomialBasisFunction(basis_name, degree, variate, sol_domain);
    [D, F] = ApplyGoverningEquation();
    [D, F] = ApplyBoundaryConditions(D, F);
    sol = D \ F;
    n = length( basis );
    d = sol(1:n);
    lambda = sol(n+1:end);
    u = transpose(d) * basis;
end
```

```{matlab}
clear
x = sym( "x", "real" );
fun.target_fun = sin( pi * x )^2 + cos( x ) - 1;
fun.domain = [0, 1];

sol_space = PolynomialSolutionSpace();
sol_space.variate = x;
sol_space.domain = [0, 1];
sol_space.degree = 2;
sol_space.basis_name = "Monomial";
[u, M, F, basis, d] = ScalarProjection( fun, sol_space );
```

```{matlab}
%| echo: false
figure
hold on
fplot( fun.target_fun, double( fun.domain ), linewidth=4, DisplayName="$f(x)$" )
fplot( u, double( fun.domain ),              linewidth=3, DisplayName="$\tilde{f}(x)$" )
legend()
```

```{matlab}
%| echo: false
figure
hold on
fplot( sqrt( ( u - fun.target_fun )^2 ), double( fun.domain ), linewidth=4, DisplayName="$f(x)$" )
```

## Strongly-enforced boundary conditions
We'll enumerate the methods first, before diving into each.

1. Preselecting a basis that interpolates the boundary condition
2. Computing a modified basis that interpolates the boundary condition

### Choosing an interpolatory basis

```{matlab}
%| output: false
function [u, D, F, basis, d] = ScalarProjection( fun, sol_space )

    function [D, F] = ApplyGoverningEquation()
        function D = AssembleGramMatrix()
            D = int( basis * transpose( basis ), domain );
        end

        function F = AssembleForceVector()
            F = int( basis * target_fun, domain );
        end
        D = AssembleGramMatrix();
        F = AssembleForceVector();
    end

    function [D, F] = ApplyBoundaryConditions( D, F )
        function [D, F] = LeftFunctionValue(D, F)
            D(1,:) = 0;
            D(:,1) = 0;
            D(1,1) = 1;
            F(1) = subs( target_fun, variate, domain(1) );
        end
        function [D, F] = RightFunctionValue(D, F)
            D(end,:) = 0;
            D(:,end) = 0;
            D(end,end) = 1;
            F(end) = subs( target_fun, variate, domain(2) );
        end
        [D, F] = LeftFunctionValue(D, F);
        [D, F] = RightFunctionValue(D, F);
    end

    % Unpack the solution space
    variate = sol_space.variate;
    basis_name = sol_space.basis_name;
    degree = sol_space.degree;
    sol_domain = sol_space.domain;
    
    % Unpack the function parameters
    target_fun = fun.target_fun;
    domain = fun.domain;

    % Solve
    basis = PolynomialBasisFunction( basis_name, degree, variate, sol_domain );
    [D, F] = ApplyGoverningEquation();
    [D, F] = ApplyBoundaryConditions( D, F );
    d = D \ F;
    u = transpose( d ) * basis;
end
```

```{matlab}
clear
x = sym( "x", "real" );
fun.target_fun = sin( pi * x )^2 + cos( x ) - 1;
fun.domain = [0, 1];

sol_space = PolynomialSolutionSpace();
sol_space.variate = x;
sol_space.domain = [0, 1];
sol_space.degree = 2;
sol_space.basis_name = "Lagrange";
[u, M, F, basis, d] = ScalarProjection( fun, sol_space )
```

```{matlab}
%| echo: false
figure
hold on
fplot( fun.target_fun, double( fun.domain ), linewidth=4, DisplayName="$f(x)$" )
fplot( u, double( fun.domain ),              linewidth=3, DisplayName="$\tilde{f}(x)$" )
legend()
```

```{matlab}
%| echo: false
figure
hold on
fplot( sqrt( ( u - fun.target_fun )^2 ), double( fun.domain ), linewidth=4, DisplayName="$f(x)$" )
```

### Computing an interpolatory basis

```{matlab}
%| output: false
function [u, D, F, basis, d] = ScalarProjection(fun, sol_space)

    function [D, F] = ApplyGoverningEquation()
        D = int( basis * transpose(basis), domain );
        F = int( basis * target_fun,        domain );
    end

    function [C, gstar] = ApplyBoundaryConditions(D, F)
        % Constraint matrix C d = g*
        C = [transpose(subs(basis, variate, domain(1))); 
             transpose(subs(basis, variate, domain(2)))];

        g = [subs(target_fun, variate, domain(1)); 
             subs(target_fun, variate, domain(2))];
    end

    function d0 = ParticularSolution_MinNorm(C, gstar, n)
        % A convenient particular solution when C has full row rank:
        %   d0 = C^T (C C^T)^{-1} g*
        % This satisfies C d0 = g* (exactly in symbolic arithmetic,
        % up to roundoff in floating arithmetic).
        d0 = C.' * ((C*C.') \ gstar);

        % Ensure shape n x 1 even if something odd happens
        if size(d0,2) ~= 1
            d0 = reshape(d0, [n, 1]);
        end
    end

    % -----------------------
    % Unpack the solution space
    % -----------------------
    variate    = sol_space.variate;
    basis_name = sol_space.basis_name;
    degree     = sol_space.degree;
    sol_domain = sol_space.domain;

    % penalty is not used in the nullspace method (strong enforcement)
    % penalty  = sol_space.penalty;

    % -----------------------
    % Unpack the function parameters
    % -----------------------
    target_fun = fun.target_fun;
    domain     = fun.domain;

    % -----------------------
    % Assemble basis + interior projection system
    % -----------------------
    basis = PolynomialBasisFunction(basis_name, degree, variate, sol_domain);

    [G, fvec] = ApplyGoverningEquation();

    % -----------------------
    % Assemble constraints C d = g*
    % -----------------------
    [C, gstar] = AssemblePointDirichletConstraints();

    n = length(basis);
    m = size(C,1);

    % Basic rank check: constraints must be independent
    if rank(C) < m
        error('ScalarProjection_Nullspace:ConstraintRank',...
              'Constraint matrix C does not have full row rank. Constraints are redundant or incompatible with the chosen basis.');
    end

    % -----------------------
    % Build nullspace basis Z and a particular solution d0
    % -----------------------
    Z  = null(C);                          % n x (n-m), C*Z = 0
    d0 = ParticularSolution_MinNorm(C, gstar, n);  % n x 1, C*d0 = g*

    % (Optional sanity check; comment out if you want)
    % residual = simplify(C*d0 - gstar);

    % -----------------------
    % Reduced (BC-satisfying) solve in coordinates a
    % -----------------------
    Dred = transpose(Z) * G * Z;
    Fred = transpose(Z) * (fvec - G*d0);

    a = Dred \ Fred;                       % (n-m) x 1
    d = d0 + Z*a;                          % n x 1 (satisfies BCs exactly)

    % Reconstruct function
    u = transpose(d) * basis;
end
```

```{matlab}
clear
x = sym( "x", "real" );
fun.target_fun = sin( pi * x )^2 + cos( x ) - 1;
fun.domain = [0, 1];

sol_space = PolynomialSolutionSpace();
sol_space.variate = x;
sol_space.domain = [0, 1];
sol_space.degree = 2;
sol_space.basis_name = "Lagrange";
[u, M, F, basis, d] = ScalarProjection( fun, sol_space )
```

```{matlab}
%| echo: false
figure
hold on
fplot( fun.target_fun, double( fun.domain ), linewidth=4, DisplayName="$f(x)$" )
fplot( u, double( fun.domain ),              linewidth=3, DisplayName="$\tilde{f}(x)$" )
legend()
```

```{matlab}
%| echo: false
figure
hold on
fplot( sqrt( ( u - fun.target_fun )^2 ), double( fun.domain ), linewidth=4, DisplayName="$f(x)$" )
```