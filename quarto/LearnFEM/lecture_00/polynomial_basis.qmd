---
engine: julia
---
```{julia}
#| include: false
import Pkg
Pkg.activate( "../LearnFEM" )
import Symbolics, Latexify, SymbolicUtils, LaTeXStrings, Nemo
import LinearAlgebra
import Plots
include( "lecture_00.jl" )
using .lecture_00: ChangeOfVariable, PlotPolynomialBasis
```

# Polynomial Basis
What is a polynomial?
Chances are that you have a pretty good basic understanding of polynomials, you know a polynomial when you see it.
But you may not have considered polynomials as being a vector space, of each polynomial function being describable as a linear combination of coefficients and a polynomial basis.
Let's investigate.

## The Monomial Basis
The polynomial basis probably most familiar to the reader is the *monomial basis*, sometimes called the *power basis*.

```{julia}
function MonomialBasis( degree, variate, domain )
    variate = ChangeOfVariable( variate, domain, [0, 1] )
    basis = []
    for n in range( 0, degree )
        append!( basis, variate^n )
    end
    return basis
end
```

These basis polynomials are, as the name suggests, the familiar monomials and, as such, is normally defined over the unit domain $[0,1]$.

```{julia}
#| output: false
import Symbolics
degree = 4
Symbolics.@variables x
domain = [ Symbolics.Num( 0 ), Symbolics.Num( 1 ) ]
monomial_basis = MonomialBasis( degree, x, domain )
```

```{=latex}
\begin{equation*}
    \Matrix{M}
    =
    \begin{bmatrix}
        x^0 \\
        x^1 \\
        x^2 \\
        x^3 \\
        x^4
    \end{bmatrix}
\end{equation*}
```

```{julia}
#| echo: false
p = PlotPolynomialBasis( "Monomial", degree, x, domain )
```

However, including the change of variable operator in its construction allows for defining the monomial basis over any domain, such as the bi-unit domain $[-1,1]$

```{julia}
#| output: false
domain = [ Symbolics.Num( -1 ), Symbolics.Num( 1 ) ]
monomial_basis = MonomialBasis( degree, x, domain )
```

<!-- ```{julia}
#| echo: false
Markdown( f"$${BasisToLatexString( monomial_basis, "M" )}$$" )
``` -->

```{julia}
#| echo: false
p = PlotPolynomialBasis( "Monomial", degree, x, domain )
```

## The Lagrange Basis

The Lagrange basis is a so-called *interpolatory basis* and has wide applications in interpolation and approximation.
In fact, because of its interpolation properties it is the *de facto* standard basis used in traditional finite element codes.
It also gives rise to the Lagrange interpolating polynomial.

```{julia}
function LagrangeBasis( degree, variate, domain )
    node = LinRange( domain[1], domain[2], degree + 1 )
    basis = []
    for i = 1 : degree + 1
        append!( basis, variate^0 )
        for j = 1 : degree + 1
            if i != j
                basis[i] *= ( ( variate - node[j] ) / ( node[i] - node[j] ) )
            end
        end
    end
    return basis
end
```

Note that the Lagrange basis is usually defined over the bi-unit domain $[-1, 1]$.

```{julia}
#| output: false
degree = 4
Symbolics.@variables x
domain = [ Symbolics.Num( -1 ), Symbolics.Num( 1 ) ]
lagrange_basis = LagrangeBasis( degree, x, domain )
```

```{julia}
#| echo: false
PlotPolynomialBasis( "Lagrange", degree, x, domain )
```

## The Bernstein Basis

The Bernstein basis is both a historically significant basis and currently a vital basis in the fields of approximation, computer-aided design, computer graphics, and even computer font design.
It forms the foundation for such things as Bezier curves, B-splines, NURBS, and isogeometric analysis.
We will talk more about these later.

Note that the Bernstein basis is usually defined over the unit domain $[0,1]$.

```{julia}
function BernsteinBasis( degree, variate, domain )
    variate = ChangeOfVariable( variate, domain, [0, 1] )
    basis = []
    for i = 0 : degree
        bin_coeff = binomial( degree, i )
        monomial = variate^i
        polynomial = ( 1 - variate ) ^ ( degree - i )
        append!( basis, bin_coeff * monomial * polynomial )
    end
    return basis
end
```

```{julia}
#| ouput: false
degree = 4
Symbolics.@variables x
domain = [ Symbolics.Num( 0 ), Symbolics.Num( 1 ) ]
bernstein_basis = BernsteinBasis( degree, x, domain )
```

```{julia}
#| echo: false
PlotPolynomialBasis( "Bernstein", degree, x, domain )
```

## The Legendre basis

The Legendre basis is the first of the orthogonal basis, so-called each basis polynomial is orthogonal in the $L^2$-norm to every other polynomial in the basis --- we'll define what this means later.
For now, it's enough to know that this orthogonality property provides a number of desirable numerical properties, even at high polynomial degree (especially in contrast to the Lagrange basis), and will prove especially useful when we later develop numerical quadrature schemes.

```{julia}
function LegendreBasis( degree, variate, domain )
    variate = ChangeOfVariable( variate, domain, [-1, 1] )
    basis = []
    for i = 0 : degree + 1
        if i == 0
            append!( basis, variate^0 )
        elseif i == 1
            append!( basis, variate^1 )
        else
            n = i - 1
            term_1 = ( 2 * n + 1 ) * variate * basis[i]
            term_2 = n * basis[i-1]
            append!( basis, ( term_1 - term_2 ) / ( n + 1 ) )
        end
    end
    return basis
end
```

```{julia}
#| output: false
degree = 4
Symbolics.@variables x
domain = [ Symbolics.Num( -1 ), Symbolics.Num( 1 ) ]
legendre_basis = LegendreBasis( degree, x, domain )
```

```{julia}
#| echo: false
PlotPolynomialBasis( "Legendre", degree, x, domain )
```

## The Chebyshev basis

The Chebyshev basis is another orthogonal basis, however its orthogonality is defined slighlty differently than the Legendre basis.
We will discuss this nuance later, but it is sufficient to say that it too has many beneficial numerical properties stemming from its orthogonality and is incredibly important in modern approximation theory.
Due to various transliterations of its namesake, [Pafnuty Chebyshev](https://en.wikipedia.org/wiki/Pafnuty_Chebyshev), it is sometimes written as *Tchebycheff*, *Tchebyshev* (French), or *Tschebyschow* (German).

```{julia}
function ChebyshevBasis( degree, variate, domain )
    variate = ChangeOfVariable( variate, domain, [-1, 1] )
    basis = []
    for i = 0 : degree
        if i == 0
            append!( basis, variate^0 )
        elseif i == 1
            append!( basis, variate^1 )
        else
            append!( basis, ( 2 * variate * basis[i] ) - basis[i-1] )
        end
    end
    return basis
end
```

```{julia}
#| output: false
degree = 4
Symbolics.@variables x
domain = [ Symbolics.Num( -1 ), Symbolics.Num( 1 ) ]
chebyshev_basis = ChebyshevBasis( degree, x, domain )
```

```{julia}
#| echo: false
PlotPolynomialBasis( "Chebyshev", degree, x, domain )
```

## Other Basis Polynomials

There are a multitude of other basis polynomials which we will not show here.
Several of these basis that are commonly used are variations of the Lagrange basis, where the roots of the Legendre and Chebyshev basis are used as the nodes (roots) of the Lagrange basis.
The resulting basis, while perhaps not as commonly used as the aforementioned basis, inherit some of the beneficial numerical properties of their orthogonal progenitors.[^1]
Also included are various other orthogonal polynomials such as the Leguerre, Lobatto, Hermite, and Jacobi polynomials, to name a few.

[^1]: Such as minimizing the deleterious Runge phenomenon observed with high-order polynomial interpolants.

## A Polynomial Basis Interface

To simplify accessing the various basis polynomials later in this text, let's define an interface method:

```{julia}
function PolynomialBasisFunction( basis_name, degree, variate, domain )
        if basis_name == "Bernstein"
            basis = BernsteinBasis( degree, variate, domain )
        elseif basis_name == "Chebyshev"
            basis = ChebyshevBasis( degree, variate, domain )
        elseif basis_name == "Lagrange"
            basis = LagrangeBasis( degree, variate, domain )
        elseif basis_name == "Legendre"
            basis = LegendreBasis( degree, variate, domain )
        elseif basis_name == "Monomial"
            basis = MonomialBasis( degree, variate, domain )
        end
        return basis
    end
```